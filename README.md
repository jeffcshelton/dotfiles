# dotfiles

These are my personal dotfiles.

# Install

If you want to try out my configuration on your personal machine, just run this
command:

```sh
$ sh <(curl -L https://shelton.one/install)
```

**NOTE:** While it's simple to test out and roll back a configuration on NixOS,
this is not nearly as easy on macOS. I would not recommend trying out my config
on macOS, but feel free to look around the repository for ideas!

# Nix

My configuration is heavily based on Nix. I use macOS on my laptop with the
[Nix package manager](http://nixos.org), with NixOS on the desktop. Despite
this, I also do lots of deployments to Debian and Fedora machine, so I have
decided not to configure my programs with [home-manager](), instead opting to
use dotfiles directly. There are limited exceptions for programs that
effectively require home-manager for programmatic configuration, because they
don't accept dotfiles.

## Structure

The [nix](./nix) directory is structured around modules that each host can
either include or not, all of which are independent of each other.

The [hosts](./nix/hosts) directory contains Nix files corresponding to the
hostnames of my Nix-enabled machines. Each machine is named after figures in
Roman mythology.

1. Jupiter - My x86\_64 Linux desktop running NixOS. This is my primary
development workstation.

2. Mercury - My M1 Macbook Pro running macOS.

3. Ceres - An arm64 virtual machine hosted on Mercury running NixOS. I use
this VM to test out new Nix configurations and do any Linux-required development
while on the go.

### Hardware

The hardware configuration for NixOS machines is auto-generated by the NixOS
installer. To add a new machine, I run the installer and transfer the contents
of `/etc/nixos/hardware-configuration.nix` into a new file under
[hosts](./nix/hosts). As hardware is updated, this host file must be updated to
reflect that new hardware.

### Modules

Whatever machine a software component is used on (Hyprland, for example), I
always want that component to be configured identically. However, I don't want
all modules to be present on all machines. In some examples, not all modules are
even _compatible_ with all machines. My Hyprland configuration doesn't run on
Ceres, for example, because it is a VM, which Hyprland doesn't support.

So I have separated out software components into "modules" which I can
selectively include or exclude on a per-machine basis. These are present in the
[modules](./nix/modules) directory and are imported into the host `.nix` files.

Every module must be fully responsible for itself. If it has a dependency on
another module, then it must import it. This compartmentalizes the modules and
makes them easily swappable.
